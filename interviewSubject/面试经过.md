### 字节跳动：

git reset 几种模式 git rebase pull

面向对象  依赖倒置  控制反转

redux和vuex设计上的异同    mvc 和mvvm怎么分层

vue3和vue2  diff算法的优化 ，编译上的优化 patchflags

http  websocket   keepalive

最长递增子序列

typescript 泛型的作用

### 虾皮：

代码考察：

事件循环的输出

箭头函数普通函数 this 的输出

有效括号数

数组转tree



性能优化  懒加载 按需加载 的实现原理

https数字证书验证

options请求

vue3的提升  静态标记的提升 vue2 元素的某个属性动态变化也会导致整个节点是动态的，vue3则具体到某个属性了

 css选择器以及优先级

vue scoped的实现原理

flex布局常用属性与场景

ES6的的常用变化

Cookie  samesite

Vue.set  属性动态新增或删除时才会用到，只是更新是可以观察到的

最认可的项目

联影
设计模式
数据结构与算法
二叉树 以及 如何做到平衡
超大像素图片的性能优化
前端内存以及计算上面的优化



### tp-link

手写：校验MAC地址是否合法
强制与隐形类型转换
CSP内容安全策略
http缓存
垂直居中
常用设计模式
发布订阅与观察者模式的区别
BFC
vue2，3响应式数据 proxy Object.defineProperty
vue虚拟dom和react区别

反向代理 负载均衡 CDN的先后顺序
设计模式
vue2和vue3
最近比较代表性的项目
CDN缓存刷新
浏览器url变更 到服务器的过程
前端性能优化
webpack loader与plugin

### socialbook：

将一个对象的key从驼峰转换为下划线的写法，递归与迭代两种方法
找处一串字符串中合法的json字符串
实现一个队列，用o(1)的时间复杂度获取其中的最大最小值
斗地主残局的胜负判别
给图片中的一些确定的点打标签，尽可能使得标签和点不重叠，解决方案
首屏性能优化
耦合与内聚

### Xtransfer 电信翼支付：

nexttick原理
webapck的几种hash、热更新原理，性能优化
vue3静态提升 与vue2的提升
深浅拷贝  以及循环引用(使用map缓存)
diff算法原理
闭包
资源预加载preload和资源预读取prefetch的区别
提高webpack构建速度

### 分贝通：

微前端应该当怎么去划分实现
CDN如何与源站内容一致
实现红色半透明圆的方案，几种

### 一点资讯：

性能错误监控
移动端刘海屏的适配
数组去重

### 乐读：

三栏布局 两边固定 中间自适应 

移动端适配

ES6  Promise  async await    Map和set的异同

```javascript
let arr = [1, 3, 6, 7, 8, 10, 11]; => [[1,3],[6,8],[10],[11]] 单调递增的数组，取连续子数组的最大最小值

const fn = array =&gt; {
let res = [],
item = [array[0]]
for(let i = 1; i &lt; array.length; i++) {
if(array[i] - array[i-1] === 1){
if(i !== arr.length - 1) continue;
else item.push(arr[i]);
} else {
item[0] !== array[i-1] &amp;&amp; item.push(array[i-1])
res.push(item)
item = [array[i]]
}
}
res.push(item)
return res;
}

console.log(fn(arr))
```

v-html 弊端

v-directive 自定义指令

浏览器端缓存，cookie ， sessionStorage 和 localStorage，以及http缓存的流程

如何在前端控制不使用缓存，

浏览器垃圾回收

工作中遇到的比较难忘的问题

技术宽度：node  typescript  electron  canvas  h5小游戏 设计模式

### 牛客网：

vite 与 webpack

vue keepalive 

http常见状态码

computed 和 watch

cookie sessionStorage localStorage

setTimeout实现setInterval

eventBus手写

事件循环 判断

setTimeout(function () {
  console.log("1");
}, 0);
async function async1() {
  console.log("2");
  const data = await async2();
  console.log("3");
  return data;
}
async function async2() {
  return new Promise((resolve) => {
    console.log("4");
    resolve("async2的结果");
  }).then((data) => {
    console.log("5");
    return data;
  });
}
async1().then((data) => {
  console.log("6");
  console.log(data);
});
new Promise(function (resolve) {
  console.log("7");
  //   resolve()
}).then(function () {
  console.log("8");
});

