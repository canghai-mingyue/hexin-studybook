### 字节跳动：

git reset 几种模式 git rebase pull

面向对象  依赖倒置  控制反转

redux和vuex设计上的异同    mvc 和mvvm怎么分层

vue3和vue2  diff算法的优化 ，编译上的优化 patchflags

http  websocket   keepalive

最长递增子序列

typescript 泛型的作用

### 虾皮：

代码考察：

事件循环的输出

箭头函数普通函数 this 的输出

有效括号数

数组转tree



性能优化  懒加载 按需加载 的实现原理

https数字证书验证

options请求

vue3的提升  静态标记的提升 vue2 元素的某个属性动态变化也会导致整个节点是动态的，vue3则具体到某个属性了

 css选择器以及优先级

vue scoped的实现原理

flex布局常用属性与场景

ES6的的常用变化

Cookie  samesite

Vue.set  属性动态新增或删除时才会用到，只是更新是可以观察到的

最认可的项目

### tp-link

手写：校验MAC地址是否合法
强制与隐形类型转换
CSP内容安全策略
http缓存
垂直居中
常用设计模式
发布订阅与观察者模式的区别
BFC
vue2，3响应式数据 proxy Object.defineProperty
vue虚拟dom和react区别

反向代理 负载均衡 CDN的先后顺序
设计模式
vue2和vue3
最近比较代表性的项目
CDN缓存刷新
浏览器url变更 到服务器的过程
前端性能优化
webpack loader与plugin

### socialbook：

将一个对象的key从驼峰转换为下划线的写法，递归与迭代两种方法
找处一串字符串中合法的json字符串
实现一个队列，用o(1)的时间复杂度获取其中的最大最小值
斗地主残局的胜负判别
给图片中的一些确定的点打标签，尽可能使得标签和点不重叠，解决方案
首屏性能优化
耦合与内聚

### Xtransfer 电信翼支付：

nexttick原理
webapck的几种hash、热更新原理，性能优化
vue3静态提升 与vue2的提升
深浅拷贝  以及循环引用(使用map缓存)
diff算法原理
闭包
资源预加载preload和资源预读取prefetch的区别
提高webpack构建速度

### 分贝通：

微前端应该当怎么去划分实现
CDN如何与源站内容一致
实现红色半透明圆的方案，几种

### 一点资讯：

性能错误监控
移动端刘海屏的适配
数组去重

### 乐读：

三栏布局 两边固定 中间自适应 

移动端适配

ES6  Promise  async await    Map和set的异同

```javascript
let arr = [1, 3, 6, 7, 8, 10, 11]; => [[1,3],[6,8],[10],[11]] 单调递增的数组，取连续子数组的最大最小值

const fn = array =&gt; {
let res = [],
item = [array[0]]
for(let i = 1; i &lt; array.length; i++) {
if(array[i] - array[i-1] === 1){
if(i !== arr.length - 1) continue;
else item.push(arr[i]);
} else {
item[0] !== array[i-1] &amp;&amp; item.push(array[i-1])
res.push(item)
item = [array[i]]
}
}
res.push(item)
return res;
}

console.log(fn(arr))
```

v-html 弊端

v-directive 自定义指令

浏览器端缓存，cookie ， sessionStorage 和 localStorage，以及http缓存的流程

如何在前端控制不使用缓存，

浏览器垃圾回收

工作中遇到的比较难忘的问题

技术宽度：node  typescript  electron  canvas  h5小游戏 设计模式

### 牛客网：

vite 与 webpack

vue keepalive 

http常见状态码

computed 和 watch

cookie sessionStorage localStorage

setTimeout实现setInterval

eventBus手写

事件循环 判断

setTimeout(function () {
  console.log("1");
}, 0);
async function async1() {
  console.log("2");
  const data = await async2();
  console.log("3");
  return data;
}
async function async2() {
  return new Promise((resolve) => {
    console.log("4");
    resolve("async2的结果");
  }).then((data) => {
    console.log("5");
    return data;
  });
}
async1().then((data) => {
  console.log("6");
  console.log(data);
});
new Promise(function (resolve) {
  console.log("7");
  //   resolve()
}).then(function () {
  console.log("8");
});

